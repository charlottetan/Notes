{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"About the Site This site contains my notes when reading papers. As I only write down important or interesting parts for me, they may not be good summaries. Fields of Interest I'm mainly interested in large-scale data systems including Ethereum and block-chain based systems. \"A future is not given to you. It is something you must take for yourself.\"","title":"Home"},{"location":"gfs/gfs.html","text":"The Google File System A scalable distributed file system for large distributed data-intensive applications. Introduction The design is driven by key observations different from earlier file system assumptions: frequent component failures, huge files (GB+), most files are mutated by appending rather than overwriting. GFS provides a POSIX-like file system interface. It supports snapshot and record append operations(useful for multi-way merge and consumer/producer). Architecture Figure 1 A GFS cluster consists of a single master and multiple chunkservers and is accessed by multiple clients. Files are divided into fixed-sized chunks(64 MB, larger than typical) and each chunk has an immutable and globally unique id. Chunkservers store chunks as local Linux files and the master maintains all file system metadata. The master stores in memory three majors types of metadata: the file and chunk namespaces, the mapping from files to chunks and the locations of each chunk's replicas. The first two are also persisted in a replicated operation log(with checkpoints); the last one is polled from chunkservers at start time and kept up-to-date via heartbeat messages. Reads Using the fixed chunk size, the client translates the file name and byte offset into a chunk index within the file. Sends the master a request containing the file name and chunk index. The master replies with the corresponding chunk handle and locations of the replicas. The client caches this information using the file name and chunk index as the key. The client then sends a request to one of the replicas,most likely the closest one. The request specifies the chunk handle and a byte range within that chunk. Further reads of the same chunk require no more client-master interaction until the cached information expires. Chunk Size Key design parameters, Large chunk chosen : 64MB Advantages Reduces clients' need to interact with the master Operations are more likely to target at the same chunk, can reduce network overhead by keeping a persistent TCP connection to the chunkserver over an extended period of time Reduces metadata size, easier for master to store in memory Disadvantages Small files -> small # of chunks -> the chunkserver becomes a hot spot Operation Log Contains a historical record of critical metadata changes. Replicated on multiple remote machines. Respond to a client operation only after flushing the corresponding log record to disk both locally and remotely. Recovers file system by replaying the log. Master checkpoints its state in a compact B-tree like form whenever the log grows beyond a certain size. Only keeps latest complete checkpoint and subsequent log files. Figure 2 System Interactions Leases and Mutation Order For mutations to a chunk, the master grants an extendable chunk lease to one of the replicas. The primary will pick a serial order for all mutations to the chunk and all replicas will follow this order. Control and data flows are decoupled to use the network efficiently. Control flows from the client to the primary and then to all secodaries. Data is pushed linearly along a carefully picked chain of chunkservers in a pipelined fashion. GFS provides at-least-once semantics. A client retries when mutation fails, so replicas of the same chunk may contain different data including duplicates or paddings(not bytewise identical). Writes Client asks the master which chunkserver holds the current lease for the chunk and replica locations. Master replies with primary and secondaries locations. Caches this until primary unavailable/no longer has lease. Client pushes the data to all the replicas. Each chunkserver will store the data in an internal LRU buffer cache. After all the replicas ack, client sends a write request to the primary. Primary assigns write order to all mutations it receives. Primary forwards the write request to all secondary replicas with mutation order. Secondaries ack to primary on completion. Primary replies to client. Failure -> client retry. Master Operations GFS namespace is represented as a lookup table(with prefix compression) from full pathnames to metadata. Each file or directory has a read-write lock to ensure proper searialization. The master create chunk replicas for initial creation, re-replication and rebalancing. It considers various factors when placing the replica, to maximizing data reliability/availability/network bandwidth utilization. When a file is deleted, the master logs the deletion immediately but deletes metadata after some delay(3 days, etc). Each chunkserver reports a subset of chunks in heartbeat messages, and the master replies whether these chunks can be deleted. This lazy approach is simple and reliable in a large-scale distributed system. The master maintains a version number for each chunk. Whenever the master grants a new lease on the chunk, it increases the version number and informs all the up-to-date replicas. For high availability, we have (1) monitoring infrastructure outside GFS to start a master and (2) \"shadow\" masters for read-only operations. Fault Tolerance High Availability Fast Recovery - Both the master and the chunkserver are designed to restore their state and start in seconds. Chunk Replication - default 3 replications per chunk. Master Replication - Operation log and checkpoints replicated on multiple machines. \"Shadow\" masters above. Data Integrity Breaks each 64 MB chunk into blocks of 64 KB, each with its own 32-bit checksum stored in memory and written to the log. For reads, the chunkserver verifies the checksum of datablocks that overlap the read range before returning any data to the requester If a block does not match the recorded checksum, the chunkserver returns an error and and reports the mismatch to the master. In response, the requestor will read from other replicas, while the master will clone the chunk from another replica. After a valid new replica is in place, the master instructs the chunkserver that reported the mismatch to delete its replica. Summary Good Ideas High Availability through fast recovery of master and chunkserver. Separation of naming (master) from storage (chunkserver). Sharding (chunk replication) for parallel throughput. Primary to sequence writes. Leases to prevent split-brain chunkserver primaries. Not So Good Single master performance : Ran out of RAM and CPU as file count increased 1000x Chunkservers not very efficient for small files Lack of automatic fail-over to master replica","title":"gfs"},{"location":"mapreduce/mapreduce.html","text":"MapReduce: Simplified Data Processing on Large Clusters A programming model and an associated implementation for processing and generating large data sets. Introduction Many computation tasks are conceptually straightforward, but given the size of input data, the computations have to be distributed across machines to finish in a reasonable amount of time. MapReduce is an abstraction that can express many computation tasks while hiding details of parallelization, fault-tolerance, data distribution and load balancing. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. map (k1,v1) \u2192 list(k2,v2) reduce (k2,list(v2)) \u2192 list(v2) Implementation Execution A single master assigns tasks to workers; there are M map tasks and R reduce tasks in total. For map task, worker reads input, applies user-defined Map function and periodically writes intermediate results buffered in memory to local disk partitioned into R regions. The locations of these buffered pairs on disk are passed back to the master, who forwards these locations to the reduce workers. For reduce task, worker uses rpcs to read intermediate results on map workers' local disks, sorts intermediate results to group occurrences of the same key, applies user-defined Reduce function and writes final results to a global file system. Master is responsible of propagating the locations of intermediate files from map tasks to reduce tasks. Master Data Structures stores state(idle, in-progress, competed) and identity of the worker machine for each task (non idle). for each completed map task: locations and sizes of the R intermediate file regions. The information is pushed incrementally to in-progress reduce workers. Fault Tolerance For worker failure, master periodically pings workers and marks the worker that has no response for a certain amount of time as failed. Completed and in-progress map tasks are reset to idle and reduce workers executing are notified. Completed map tasks and any in-progress tasks on that worker are rescheduled to other workers; no need to re-execute completed reduce tasks because output is stored in global file system instead of worker's local disk. For master failure, the computation is just aborted and it is client's responsibility to check and retry. Miscellaneous Locality: master attempts to schedule map tasks on or close to the machines that contains corresponding input data(input data managed by GFS is also stored in the cluster). Task granularity: ideally M and R should be large to improve load balancing and speed up failure recovery, but there are practical bounds since master needs to keep O(M\\times R) states in memory and each reduce task produces a separate output file. Backup tasks: when the MapReduce is close to completion, master schedules backup executions for remaining in-progress tasks to alleviate the problem of stragglers. MR takes 44% longer without backup tasks. Refinements Partitioning Function: Typically hash(key) mod R is used for hashing. However, it is useful to allow custom partitioning function so that for example users can have all URLs from the same host end up in the same output file. Combiner Function: In some cases, there is significant repetition in the intermediate keys produced by each map task. For example, word count map produces <word, 1> for each word. All of these counts will be sent over RPC. Better allow user to specify optional Combiner that does partial merging of data before sent to reducers.","title":"mapreduce"},{"location":"raft/raft.html","text":"Raft: In Search of an Understandable Consensus Algorithm A consensus algorithm for managing a replicated log MIT Notes Part1 Part2 Raft Basics Properties Election Safety : at most one leader can be elected in a given term. Leader Append-Only : a leader never overwrites or deletes entries in its log; it only appends new entries. Log Matching : if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index. Leader Completeness : if a log entry is committed in a given term, then that entry will be present in the logs of the leaders for all higher-numbered terms. State Machine Safety : if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index. Raft divides time into terms of arbitrary length. Used extensively in leader election and log matching. Leader Election When servers start up, they begin as followers Leader sends periodic heartbeats (AppendEntries RPC with no log entries) to all followers to maintain authority. If follower receives no communication over election timeout , then it assumes there is no viable leader and begins an election to choose a new leader. Begin an election: follower increments its current term and transitions to candidate state, votes for itself and issue RequestVoteRPCs in parallel to each else Candidate continue in this state until one of three things happens: a. it wins b. other wins c. no one wins Candidate wins if it receives the majority of votes, voting is first-come-first-served. While waiting for votes, a candidate may receive an AppendEntries RPC from another server claiming to be leader. If its term is larger or equal than itself's, the candidate recognizes the leader as legit and returns to follower state Case : No one wins -> after timeout, new election (150ms - 300ms) - Raft uses randomized election timeouts to ensure that split votes are rare. Log Replication Steps Leader appends log entry to its own log Send AppendEntry to every server When the entry has been safely replicated (as described below), the leader applies the entry to its state machine and returns the result of that execution to the client. Commit A log entry is committed once the leader that created the entry has replicated it on a majority of the servers Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines This also commits all preceding entries in the leader's log, including entries created by previous leaders Leader keep tracks of the highest index it knows to be committed, and it includes that index in future AppendEntries RPCs. Once a follower learns that a log entry is committed, it applies the entry to its local state machine. Inconsistency Handling Leader maintains a nextIndex fields for each follower. It initializes nextIndex values to the index just after the last one in its log. If follower's log is inconsistent with the leader's, the AppendEntries RPC consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC Safety Ensure each state machine executes same commands in the same order I. Election Restriction Candidate only elected as leader when its log is at least as up-to-date as any other log in that majority Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs. Term1 > Term2 -> Term1 wins Term1 == Term2 -> Log with greater length wins II. Committing entries from previous terms Never commits log entries from previous terms by counting replicas. Only log entries from the leader's current term are committed by counting replicas Once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property. Log Compaction InstallSnapshot RPC As Raft log grows without bound, it occupies more space and takes more time to replay on server startup. Snapshotting - saves entire system state to a snapshot on stable storage and the entire log up to that point is discarded. Each server takes snapshots independently covering just the committed entries in its log. Although servers normally take snapshots independently, the leader must occasionally send snapshots to followers that lag behind. This happens when the leader has already discarded the next log entry that it needs to send to a follower. Summary","title":"raft"},{"location":"tao/tao.html","text":"TAO: Facebook\u2019s Distributed Data Store for the Social Graph A geographically distributed data store that provides efficient and timely access to the social graph. Background The content Facebook presents to each user is highly tailored, so we have to perform filtering and aggregation when the content is viewed instead of when the content is created. Facebook was originally built with MySQL/PHP/memcache. This look-aside key-value cache architecture has problems like inefficient edge lists, distributed control logic and expensive read-after-write consistency. TAO is designed to handle the workload of read-mostly access to a constantly changing graph. Efficiency and availability are explicitly favored over consistency. Data Model and API Object:(id) -> (otype, (key -> value)) Association: (id1, atype, id2) -> (time, (key -> value)*) Association List: (id1, atype) -> [a1, a2, ..., an] Objects are typed nodes. Each object has a globally unique id. Associations are typed directed edges between objects; at most one association can exist between two objects. Both objects and associations may contain data as key->value pairs. Bidirectional edges are modeled as two associations. TAO keeps associations in sync with their inverses. TAO's association queries are organized around association lists(associations in descending order by the \"time\" field). A per-atype upper bound for each query is enforced( assoc_ranage(id1, atype, pos, limit) ), so the client must issue multiple queries to enumerate a longer association list. Architecture Basics TAO uses MySQL as persistent storage. Data is divided into logical shards and each database server is responsible for one or more shards. Each object id has an embedded shard_id(fixed for entire lifetime). An association is stored on the shard of its id1. Multiple caching servers together form a tier. Shards are mapped onto cache servers with consistent hashing. The TAO in-memory cache contains objects, association lists and association counts. Cache servers understand the semantics of the contents and can use them to answer queries not processed before(example: cache count zero for range query). Client issues requests directly to the appropriate cache server, which will complete the read/write request(contact other cache servers/databases if necessary). For write operation on an association with inverse, the cache server for id1 will contact the cache server for id2 and issue write to database after the inverse write is complete. TAO does not provide atomicity between two updates; hanging associations are repaired by an asynchronous job. Scaling Leader and Follower Tiers Larger tiers are problematic because they are prone to hot spots and have O(N^2) growth in all-to-all connections. We split the cache into two levels: a leader tier and multiple follow tiers. Leaders behave as the basic case, while followers will instead forward read misses and writes to leaders. To keep cache consistent, leaders asynchronously send cache maintenance messages to followers. A version number in message allows it to be ignored when arriving late. Geographically Cluster data center locations into a few regions where the intra-region latency is small. Store one copy of the social graph per region. Followers behave identically in all regions, forwarding read misses and writes to the local region's tier leader. Leaders query the local region's database regardless of whether master or slave. Writes are forwarded by the local leader to the leader in the master region. Master region is controlled separately for each shard and is automatically switched to recover from database failure. We prefer to locate all of the master databases in a single region, otherwise inverse write may introduce inter-region latency. Consistency After a write, TAO guarantees the eventual delivery of an invalidation or refill to all tiers. TAO reads marked as critical will be proxied to the master region for stronger consistency. Fault Tolerance Database failures: When a master database is down, one of its slave is promoted to be the new master. When a slave database is down, cache misses are redirected to leaders in the master region. Leader failures: Followers reroute read misses directly to the database and writes to a random replacement leader. Invalidation and refill failures: If a follower is unreachable, leader persists messages and redeliver them later. If these messages are lost due to permanent leader failure, a bulk invalidation operation is used to invalidate all data of specific shard in followers. Follower failures: Client requests are failed over to followers in other tiers.","title":"tao"}]}